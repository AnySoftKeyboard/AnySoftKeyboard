import com.anysoftkeyboard.tools.generatewordslist.GenerateWordsListFromAOSPTask
import com.anysoftkeyboard.tools.generatewordslist.GenerateWordsListTask
import com.anysoftkeyboard.tools.generatewordslist.MergeWordsListTask
import com.anysoftkeyboard.tools.makedictionary.MakeDictionaryTask

System.setProperty("file.encoding", "UTF-8")

buildscript {
    repositories {
        google()
        jcenter()
        mavenCentral()
        maven { url 'https://jitpack.io' }
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.2.1'
        classpath 'com.github.menny:GradleVersion:1cd6d47894028c58924d80238068aaf579a04663'
        classpath 'com.github.AnySoftKeyboard.AnySoftKeyboardTools:makedictionary:bebd3a85d51f7d6c514099594c583eb40b58eb8a'
        classpath 'com.github.AnySoftKeyboard.AnySoftKeyboardTools:generatewordslist:bebd3a85d51f7d6c514099594c583eb40b58eb8a'
        classpath 'org.jsoup:jsoup:1.9.1'

        classpath 'com.github.triplet.gradle:play-publisher:2.0.0-rc1'
    }
}

apply plugin: 'net.evendanan.versiongenerator'

def generators = [
        new net.evendanan.versiongenerator.generators.EnvBuildVersionGenerator.CircleCi(1000, -1600),
        new net.evendanan.versiongenerator.generators.GitBuildVersionGenerator(0, 0),
        new net.evendanan.versiongenerator.generators.StaticVersionGenerator()
]

def versionData = versionGenerator.generateVersion(4, 0, 0, generators)

def languagePacks = new ArrayList<String>()

tasks.register("writeLanguagePacksToReadMeFile") {
    doLast {
        println("## Languages in this repo")
        println("We have ${languagePacks.size()} language packs in this repo:")
        println()
        languagePacks.each { println(it) }
    }
}

subprojects {
    afterEvaluate { project ->
        def languageName = project.parent.name

        //ANDROID BASICS
        if (project.plugins.hasPlugin('com.android.library') || project.plugins.hasPlugin('com.android.application')) {
            project.android {
                compileSdkVersion 28
                buildToolsVersion '28.0.3'

                defaultConfig {
                    minSdkVersion 9
                    targetSdkVersion 28
                    versionCode versionData.versionCode
                    versionName versionData.versionName
                }
            }
        }

        if (project.plugins.hasPlugin('com.android.application')) {
            project.android {
                setProperty("archivesBaseName", "ASKLangPack-${languageName}-${versionData.versionCode}")
                defaultConfig {
                    applicationId "com.anysoftkeyboard.languagepack.${languageName}"

                    println("Binary ${path} for ${applicationId} will produce APK ${project.archivesBaseName}")
                }
            }
        }

        //PUBLISH TO PLAY-STORE
        if (project.plugins.hasPlugin('com.android.application')) {
            def image = "<img src='https://github.com/AnySoftKeyboard/LanguagePack/raw/master/languages/${project.parent.name}/apk/flag/{{IMAGE_FILENAME}}' height='16'>&nbsp;"
            if (file("flag/flag.png")) {
                image = image.replace("{{IMAGE_FILENAME}}", "flag.png")
            } else if (file("flag/flag.svg")) {
                image = image.replace("{{IMAGE_FILENAME}}", "flag.svg")
            } else {
                image = ""
            }
            def packReadMeDetails = "* ${image}${languageName.capitalize()}: [Source](https://github.com/AnySoftKeyboard/LanguagePack/tree/master/languages/${project.parent.name})"

            project.android {
                signingConfigs {
                    release {
                        def keystoreFile = file("/tmp/language_pack.keystore")
                        if (keystoreFile.exists()) {
                            storeFile keystoreFile
                            storePassword System.getenv("PACK_KEYSTORE_PASSWORD")
                            keyAlias System.getenv("PACK_KEYSTORE_ALIAS")
                            keyPassword System.getenv("PACK_KEYSTORE_KEY_PASSWORD")
                            println "Using '${storeFile.absolutePath}' to release APK ${path} (with alias '${keyAlias}')."
                        } else {
                            println "Could not find '${keystoreFile.absolutePath}' file. Can not sign release APK with release keystore! Using debug."
                            initWith signingConfigs.debug
                        }
                    }
                }

                buildTypes {
                    release {
                        signingConfig signingConfigs.release
                        zipAlignEnabled true
                        debuggable false

                        minifyEnabled false
                    }
                }
            }

            if (project.ext.shouldBePublished) {
                packReadMeDetails += " â€¢ [Play Store](https://play.google.com/store/apps/details?id=${project.android.defaultConfig.applicationId})"
                println("Project ${path} is marked for publishing")

                project.apply plugin: 'com.github.triplet.play'

                play {
                    track = 'alpha'
                    serviceAccountEmail = System.getenv().getOrDefault('PUBLISH_APK_SERVICE_ACCOUNT_EMAIL', 'dummy@example.com')
                    serviceAccountCredentials = file('/tmp/apk_upload_key.p12')
                }
            } else {
                println("Project ${path} is NOT marked for publishing")
            }

            languagePacks.add(packReadMeDetails)
        }

        //GENERATING ICONS
        def generateIconsTask = task generateLanguagePackIcons

        if (project.plugins.hasPlugin('com.android.library') && name != "base") {
            [['xxxhdpi', 96, 80], ['xxhdpi', 72, 62], ['xhdpi', 48, 40], ['hdpi', 36, 32], ['mdpi', 24, 22]].each { dimens ->
                def statusIcon = task "generateStatusIcon_${dimens[0]}"(type: Exec) {
                    commandLine "${rootDir.absolutePath}/scripts/generate_status_icon.sh", project.ext.status_icon_text, languageName, "${dimens[1]}", "${dimens[2]}", "${projectDir.absolutePath}/src/main/res/drawable-${dimens[0]}"
                }

                generateIconsTask.dependsOn.add(statusIcon)
            }
        }

        if (project.plugins.hasPlugin('com.android.application')) {
            def imageAssetsFolder = new File(new File(rootDir, "StoreStuff"), "assets")
            if (!imageAssetsFolder.exists()) {
                throw new IllegalStateException("store assets folder '${imageAssetsFolder.absolutePath} does not exist!")
            }

            def launcherAssetsDir = "${imageAssetsFolder.absolutePath}/launcher-base"
            [['xxxhdpi', 64, 24], ['xxhdpi', 48, 20], ['xhdpi', 36, 10], ['hdpi', 30, 4], ['mdpi', 22, 1]].each { dimens ->
                def convert = task "generateLauncherIcon_${dimens[0]}"(type: Exec) {
                    commandLine "${launcherAssetsDir}/generate.sh", projectDir.absolutePath, buildDir.absolutePath, "${dimens[0]}", "${dimens[1]}", "${dimens[2]}", launcherAssetsDir
                }

                generateIconsTask.dependsOn.add(convert)
            }

            def generateLogoTask = task generateStoreLogoIcon(type: Exec) {
                commandLine "${imageAssetsFolder.absolutePath}/logo-base/generate.sh", projectDir.absolutePath, buildDir.absolutePath, "${imageAssetsFolder.absolutePath}/logo-base"
            }

            generateIconsTask.dependsOn.add(generateLogoTask)
        }

        //GENERATING DICTIONARY
        //just for libs
        if (project.plugins.hasPlugin('com.android.library') && name != "base") {
            def dictionaryOutputDir = new File(project.buildDir, "dictionary")
            dictionaryOutputDir.mkdirs()

            //adding dictionary making tasks
            def mergingTask = task mergeAllWordLists(type: MergeWordsListTask) {
                inputWordsListFiles new File[0]
                outputWordsListFile new File(dictionaryOutputDir, "words_merged.xml")
                maxWordsInList 300000
            }

            task makeDictionary(type: MakeDictionaryTask) {
                dependsOn mergeAllWordLists
                inputWordsListFile new File(dictionaryOutputDir, "words_merged.xml")
                prefix languageName
            }

            //if AOSP file exists (under language/pack/dictionary/aosp.combined)
            //we'll create the generation task
            //download the words-list from AOSP at https://android.googlesource.com/platform/packages/inputmethods/LatinIME/+/master/dictionaries/
            // make sure that you are using an unzipped file. The XX_wordlist.combined file should be a plain text file.
            if (project.file('dictionary/aosp.combined').exists()) {
                println("Found ASOP words file for ${project.path}")
                def aosp = task parseAospDictionary(type: GenerateWordsListFromAOSPTask) {
                    inputFile project.file('dictionary/aosp.combined')
                    outputWordsListFile new File(dictionaryOutputDir, "aosp.xml")
                    maxWordsInList 300000
                }

                mergingTask.dependsOn.add(aosp)
                mergingTask.inputWordsListFiles = mergingTask.inputWordsListFiles.plus(aosp.outputWordsListFile)
            }

            //we can also parse text files and generate word-list based on that.
            if (project.file('dictionary/inputs').exists()) {
                def inputs = task parseTextInputFiles(type: GenerateWordsListTask) {
                    inputFiles project.file('dictionary/inputs').listFiles()
                    outputWordsListFile new File(dictionaryOutputDir, "inputs.xml")
                }
                println("Found text inputs for ${project.path} with ${inputs.inputFiles.length} files.")

                if (project.ext.dictionaryInputPossibleCharacters != null) {
                    inputs.wordCharacters = project.ext.dictionaryInputPossibleCharacters
                    println("Overriding input-text files possible characters to ${new String(inputs.wordCharacters)}.")
                }
                if (project.ext.dictionaryInputAdditionalInnerCharacters != null) {
                    inputs.additionalInnerCharacters = project.ext.dictionaryInputAdditionalInnerCharacters
                    println("Overriding input-text files possible additional inner characters to ${new String(inputs.additionalInnerCharacters)}.")
                }
                mergingTask.dependsOn.add(inputs)
                mergingTask.inputWordsListFiles = mergingTask.inputWordsListFiles.plus(inputs.outputWordsListFile)
            }

            //you can also provide pre-built word-list XMLs
            if (project.file('dictionary/prebuilt').exists()) {
                def prebuiltFiles = project.file('dictionary/prebuilt').listFiles(new FilenameFilter() {
                    @Override
                    boolean accept(File dir, String name) {
                        return name.endsWith(".xml")
                    }
                })
                println("Found prebuilt word-list folder for ${project.path} with ${prebuiltFiles.length} files.")
                mergingTask.inputWordsListFiles = mergingTask.inputWordsListFiles.plus(prebuiltFiles)
            }
        }

        //CHECKS
        if (project.plugins.hasPlugin('com.android.library') || project.plugins.hasPlugin('com.android.application')) {
            project.android {
                lintOptions {
                    disable 'ExportedReceiver'
                }
            }
        }
    }

    dependencies {
        repositories {
            google()
            jcenter()
            maven { url "https://jitpack.io" }
        }
    }
}
